=== FILE BUNDLE ===
Target: src
Files: 31


===== FILE: src/app.module.ts =====
//backend/src/app.module.ts
import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { RequestLoggerMiddleware } from "./common/middleware/request-logger.middleware";
import { MongooseModule } from "@nestjs/mongoose";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { AuthModule } from "./auth/auth.module";
import { UsersModule } from "./users/users.module";
import { ClansModule } from "./clans/clans.module";
import { envValidationSchema } from "./config/env.validation";

@Module({
    imports: [
        ConfigModule.forRoot({
            isGlobal: true,
            validationSchema: envValidationSchema,
        }),

        MongooseModule.forRootAsync({
            inject: [ConfigService],
            useFactory: async (config: ConfigService) => ({
                uri: config.get<string>("MONGO_URI")!,
            }),
        }),

        UsersModule,
        AuthModule,
        ClansModule,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        consumer
            .apply(RequestLoggerMiddleware)
            .forRoutes("*"); // MINDEN route
    }
}


===== FILE: src/auth/auth.controller.ts =====
import { Body, Controller, Get, Post, Req, UseGuards } from "@nestjs/common";
import { AuthService } from "./auth.service";
import { LoginDto } from "./dto/login.dto";
import { JwtAuthGuard } from "./jwt-auth.guard";
import { CreateUserDto } from "../users/dto/create-user.dto";

@Controller("auth")
export class AuthController {
    constructor(private auth: AuthService) {}

    @Post("login")
    login(@Body() body: LoginDto) {
        return this.auth.login(body.username, body.password);
    }

    @Post("register")
    async register(@Body() body: CreateUserDto) {
        return this.auth.registerAndLogin(body.username, body.password);
    }

    @UseGuards(JwtAuthGuard)
    @Get("me")
    me(@Req() req: any) {
        return this.auth.getMe(req.user.userId);
    }

    @Get("debug")
    debug() {
        return { bootId: process.env.BOOT_ID ?? null, pid: process.pid, now: new Date().toISOString(), azta:'paszta' };
    }

}


===== FILE: src/auth/auth.module.ts =====
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { PassportModule } from "@nestjs/passport";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { UsersModule } from "../users/users.module";
import { AuthController } from "./auth.controller";
import { AuthService } from "./auth.service";
import { JwtStrategy } from "./jwt.strategy";

@Module({
    imports: [
        UsersModule,
        PassportModule,
        ConfigModule,
        JwtModule.registerAsync({
            inject: [ConfigService],
            useFactory: async (config: ConfigService) => ({
                secret: config.get<string>("JWT_SECRET")!,
                signOptions: { expiresIn: "1d" },
            }),
        }),
    ],
    controllers: [AuthController],
    providers: [AuthService, JwtStrategy],
})
export class AuthModule {}


===== FILE: src/auth/auth.service.ts =====
//backend/src/auth/auth.service.ts
import {Injectable, UnauthorizedException} from "@nestjs/common";
import {JwtService} from "@nestjs/jwt";
import * as bcrypt from "bcryptjs";
import {UsersService} from "../users/users.service";
import {AppException} from "../common/errors/app-exception";

@Injectable()
export class AuthService {
    constructor(private users: UsersService, private jwt: JwtService) {
    }

    async login(username: string, password: string) {

        const user = await this.users.findByUsername(username);
        if (!user) throw new AppException(409, "INVALID_CREDENTIALS", "Invalid credentials", );

        const ok = await bcrypt.compare(password, user.password);
        if (!ok) throw new AppException(409, "INVALID_CREDENTIALS", "Invalid credentials", );

        const token = await this.jwt.signAsync(
            {userId: String(user._id)},
            {expiresIn: "1d"}
        );

        return {
            token,
            user: {id: String(user._id), username: user.username},
        };
    }

    async getMe(userId: string) {
        const user = await this.users.findById(userId);
        if (!user) throw new AppException(409, "INVALID_TOKEN", "Invalid token", );

        return {id: String(user._id), username: user.username};
    }

    async registerAndLogin(username: string, password: string) {
        const user = await this.users.createUser(username, password);
        const token = await this.jwt.signAsync({ userId: user.id }, { expiresIn: "1d" });

        return { token, user };
    }

}


===== FILE: src/auth/dto/login.dto.ts =====
import { IsString, MinLength } from "class-validator";

export class LoginDto {
    @IsString()
    username!: string;

    @IsString()
    @MinLength(1)
    password!: string;
}


===== FILE: src/auth/jwt-auth.guard.ts =====
import { Injectable } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";

@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {}


===== FILE: src/auth/jwt.strategy.ts =====
import { Injectable } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { ConfigService } from "@nestjs/config";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor(config: ConfigService) {
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey: config.get<string>("JWT_SECRET")!,
        });
    }

    async validate(payload: any) {
        return { userId: payload.userId };
    }
}


===== FILE: src/clans/clan.schema.ts =====
// backend/src/clans/clan.schema.ts
import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose";
import { HydratedDocument, Types } from "mongoose";

export type ClanDocument = HydratedDocument<Clan>;

@Schema({ _id: false })
export class ClanRole {
    @Prop({ required: true }) key!: string;
    @Prop({ required: true }) name!: string;
    @Prop({ type: [String], default: [] }) permissions!: string[];
}

export const ClanRoleSchema = SchemaFactory.createForClass(ClanRole);

@Schema({ _id: false })
export class ClanMember {
    @Prop({ type: Types.ObjectId, required: true }) userId!: Types.ObjectId;
    @Prop({ required: true }) roleKey!: string;
    @Prop({ type: Date, default: Date.now }) joinedAt!: Date;
}

export const ClanMemberSchema = SchemaFactory.createForClass(ClanMember);

@Schema({ timestamps: true, versionKey: false })
export class Clan {
    @Prop({ required: true, trim: true, minlength: 3, maxlength: 32 })
    name!: string;

    @Prop({ required: true, trim: true, lowercase: true, unique: true, index: true })
    slug!: string;

    @Prop({ type: [ClanRoleSchema], default: [] })
    roles!: ClanRole[];

    @Prop({ type: [ClanMemberSchema], default: [] })
    members!: ClanMember[];
}

export const ClanSchema = SchemaFactory.createForClass(Clan);


===== FILE: src/clans/clans.controller.ts =====
// backend/src/clans/clans.controller.ts
import { Body, Controller, Get, Patch, Post, Req, UseGuards } from "@nestjs/common";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { CreateClanDto } from "./dto/create-clan.dto";
import { EditClanDto } from "./dto/edit-clan.dto";
import { ClansService } from "./clans.service";

@UseGuards(JwtAuthGuard)
@Controller("clans")
export class ClansController {
    constructor(private clans: ClansService) {}

    @Get("me")
    me(@Req() req: any) {
        return this.clans.getMyClan(req.user.userId);
    }

    @Post()
    create(@Req() req: any, @Body() dto: CreateClanDto) {
        return this.clans.createClan(req.user.userId, dto);
    }

    @Patch()
    update(@Req() req: any, @Body() dto: EditClanDto) {
        return this.clans.editClan(req.user.userId, dto);
    }
}


===== FILE: src/clans/clans.module.ts =====
// backend/src/clans/clans.module.ts
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";
import { Clan, ClanSchema } from "./clan.schema";
import { ClansController } from "./clans.controller";
import { ClansService } from "./clans.service";

@Module({
    imports: [MongooseModule.forFeature([{ name: Clan.name, schema: ClanSchema }])],
    controllers: [ClansController],
    providers: [ClansService],
    exports: [ClansService],
})
export class ClansModule {}


===== FILE: src/clans/clans.roles.constants.ts =====
import {ClanPermissions} from "./permissions";

export const BaseRoles = [
    {
        key: "owner",
        name: "Owner",
        permissions: [
            ClanPermissions.Edit,
            ClanPermissions.WallWrite,
            ClanPermissions.WallModerate,
            ClanPermissions.RolesManage,
            ClanPermissions.MembersKick,
        ],
    },
    {
        key: "admin",
        name: "Admin",
        permissions: [
            ClanPermissions.Edit,
            ClanPermissions.WallWrite,
            ClanPermissions.WallModerate,
        ],
    },
    {
        key: "member",
        name: "Member",
        permissions: [],
    },
]

===== FILE: src/clans/clans.seed.ts =====
// backend/src/clans/clans.seed.ts
import { Model, Types } from "mongoose";
import { ClanDocument } from "./clan.schema";
import { BaseRoles } from "./clans.roles.constants";
import { UserDocument } from "../users/user.schema";

type RoleKey = "owner" | "admin" | "member";

function randomNonOwnerRole(): Exclude<RoleKey, "owner"> {
    return Math.random() < 0.35 ? "admin" : "member";
}

function range(from: number, to: number): number[] {
    const out: number[] = [];
    for (let i = from; i <= to; i++) out.push(i);
    return out;
}

export async function seedClans(params: {
    clanModel: Model<ClanDocument>;
}) {
    const { clanModel } = params;

    const defs = [
        { name: "Clan 1", slug: "clan-1" },
        { name: "Clan 2", slug: "clan-2" },
        { name: "Clan 3", slug: "clan-3" },
    ] as const;

    for (const d of defs) {
        await clanModel.updateOne(
            { slug: d.slug },
            {
                $setOnInsert: { name: d.name, slug: d.slug },
                $set: { roles: BaseRoles },
            },
            { upsert: true }
        );
    }

    const clans = await clanModel.find({ slug: { $in: defs.map((d) => d.slug) } }).exec();
    const bySlug = new Map(clans.map((c) => [c.slug, c]));

    return {
        clan1: bySlug.get("clan-1")!,
        clan2: bySlug.get("clan-2")!,
        clan3: bySlug.get("clan-3")!,
    };
}

export async function assignUsersToClans(params: {
    clanModel: Model<ClanDocument>;
    userModel: Model<UserDocument>;
    clanIds: { clan1Id: Types.ObjectId; clan2Id: Types.ObjectId; clan3Id: Types.ObjectId };
}) {
    const { clanModel, userModel, clanIds } = params;

    const usernames = range(1, 15).map((i) => `user${i}`);
    const users = await userModel
        .find({ username: { $in: usernames } }, { _id: 1, username: 1 })
        .lean()
        .exec();

    const idByUsername = new Map<string, Types.ObjectId>();
    for (const u of users) idByUsername.set(String(u.username), new Types.ObjectId(String(u._id)));

    const getUserId = (n: number) => {
        const id = idByUsername.get(`user${n}`);
        if (!id) throw new Error(`Clan assign: missing user${n}. (Előbb user seed!)`);
        return id;
    };

    const groups = [
        { clanId: clanIds.clan1Id, users: range(1, 5), owner: 1 },
        { clanId: clanIds.clan2Id, users: range(6, 10), owner: 6 },
        { clanId: clanIds.clan3Id, users: range(11, 15), owner: 11 },
    ] as const;

    await userModel.updateMany(
        { username: { $in: usernames } },
        { $set: { clanId: null } }
    );

    const allUserIds = groups.flatMap((g) => g.users.map((n) => getUserId(n)));
    await clanModel.updateMany(
        { "members.userId": { $in: allUserIds } },
        { $pull: { members: { userId: { $in: allUserIds } } } }
    );

    for (const g of groups) {
        const userIds = g.users.map((n) => getUserId(n));

        await userModel.updateMany(
            { _id: { $in: userIds } },
            { $set: { clanId: g.clanId } }
        );

        const members = g.users.map((n) => ({
            userId: getUserId(n),
            roleKey: n === g.owner ? ("owner" as RoleKey) : randomNonOwnerRole(),
            joinedAt: new Date(),
        }));

        await clanModel.updateOne(
            { _id: g.clanId },
            { $push: { members: { $each: members } } }
        );
    }

    return {
        assigned: groups.map((g) => ({
            clanId: String(g.clanId),
            users: g.users.length,
            owner: `user${g.owner}`,
        })),
    };
}


===== FILE: src/clans/clans.service.ts =====
// backend/src/clans/clans.service.ts
import {ConflictException, Injectable} from "@nestjs/common";
import {InjectModel} from "@nestjs/mongoose";
import {Model, Types} from "mongoose";
import {Clan, ClanDocument} from "./clan.schema";
import {CreateClanDto} from "./dto/create-clan.dto";
import {EditClanDto} from "./dto/edit-clan.dto";
import {ClanPermissions} from "./permissions";
import {AppException} from "../common/errors/app-exception"
import {BaseRoles} from "./clans.roles.constants";

function slugify(input: string) {
    return input
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "")
        .slice(0, 32);
}

@Injectable()
export class ClansService {
    constructor(@InjectModel(Clan.name) private clanModel: Model<ClanDocument>) {
    }


    private getMemberRoleKey(clan: ClanDocument, userId: string): string | null {
        const m = clan.members.find((x) => String(x.userId) === String(userId));
        return m?.roleKey ?? null;
    }

    private hasPermission(clan: ClanDocument, userId: string, perm: string): boolean {
        const roleKey = this.getMemberRoleKey(clan, userId);
        if (!roleKey) return false;

        const role = clan.roles.find((r) => r.key === roleKey);
        if (!role) return false;

        return role.permissions.includes(perm);
    }

    async createClan(ownerUserId: string, dto: CreateClanDto) {
        const slug = (dto.slug?.trim().toLowerCase() || slugify(dto.name));
        if (!slug) throw new AppException(409, "INVALID_CLAN_SLUG", "Invalid clan slug", {slug});

        const exists = await this.clanModel.exists({slug});
        if (exists) throw new AppException(409, "CLAN_SLUG_TAKEN", "Clan slug already taken", {slug});


        const created = await this.clanModel.create({
            name: dto.name.trim(),
            slug,
            roles : BaseRoles,
            members: [
                {userId: new Types.ObjectId(ownerUserId), roleKey: "owner"},
            ],
        });

        return {
            id: String(created._id),
            name: created.name,
            slug: created.slug,
            myRole: "owner",
        };
    }

    async editClan(userId: string, dto: EditClanDto) {
        if (!dto.name && !dto.slug) {
            throw new AppException(400, "NOTHING_TO_UPDATE", "Nothing to update");
        }
        const clan = await this.clanModel
            .findOne({ "members.userId": new Types.ObjectId(userId) })
            .exec();

        if (!clan) {
            throw new AppException(404, "CLAN_NOT_FOUND", "Clan not found");
        }

        const member = clan.members.find((m) => String(m.userId) === String(userId));
        if (!member) {
            throw new AppException(403, "NOT_CLAN_MEMBER", "Not a clan member");
        }

        if (!this.hasPermission(clan, userId, ClanPermissions.Edit)) {
            throw new AppException(403, "NO_PERMISSION", "No permission");
        }

        if (dto.name) {
            clan.name = dto.name.trim();
        }

        if (dto.slug) {
            const newSlug = dto.slug.trim().toLowerCase();
            if (!newSlug) throw new AppException(409, "INVALID_CLAN_SLUG", "Invalid clan slug", { slug: dto.slug });

            if (newSlug !== clan.slug) {
                const exists = await this.clanModel.exists({ slug: newSlug, _id: { $ne: clan._id } });
                if (exists) throw new AppException(409, "CLAN_SLUG_TAKEN", "Clan slug already taken", { slug: newSlug });
                clan.slug = newSlug;
            }
        }

        await clan.save();

        return {
            id: String(clan._id),
            name: clan.name,
            slug: clan.slug,
        };
    }

    async getMyClan(userId: string) {
        const clan = await this.clanModel
            .findOne({ "members.userId": new Types.ObjectId(userId) })
            .exec();

        if (!clan) {
            throw new AppException(404, "CLAN_NOT_FOUND", "Clan not found");
        }

        const myRole = this.getMemberRoleKey(clan, userId);
        if (!myRole) {
            throw new AppException(403, "NOT_CLAN_MEMBER", "Not a clan member");
        }

        const role = clan.roles.find((r) => r.key === myRole);
        const permissions = role?.permissions ?? [];

        return {
            id: String(clan._id),
            name: clan.name,
            slug: clan.slug,
            myRole,
            permissions,
        };
    }


}


===== FILE: src/clans/dto/create-clan.dto.ts =====
// backend/src/clans/dto/create-clan.dto.ts
import { IsString, MaxLength, MinLength, Matches, IsOptional } from "class-validator";

export class CreateClanDto {
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    name!: string;

    @IsOptional()
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    @Matches(/^[a-z0-9-]+$/i, { message: "slug can contain letters, numbers, dash" })
    slug?: string;
}


===== FILE: src/clans/dto/edit-clan.dto.ts =====
// backend/src/clans/dto/create-clan.dto.ts
import { IsString, MaxLength, MinLength, Matches, IsOptional } from "class-validator";

export class EditClanDto {
    @IsOptional()
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    name?: string;

    @IsOptional()
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    @Matches(/^[a-z0-9-]+$/i, { message: "slug can contain letters, numbers, dash" })
    slug?: string;
}


===== FILE: src/clans/permissions.ts =====
// backend/src/clans/permissions.ts
export const ClanPermissions = {
    Edit: "clan.edit",
    WallWrite: "clan.wall.write",
    WallModerate: "clan.wall.moderate",
    RolesManage: "clan.roles.manage",
    MembersKick: "clan.members.kick",
} as const;

export type ClanPermission = (typeof ClanPermissions)[keyof typeof ClanPermissions];


===== FILE: src/common/errors/app-exception.ts =====
// backend/src/common/errors/app-exception.ts
import { HttpException, HttpStatus } from "@nestjs/common";

export type ErrorCode = string;

export class AppException extends HttpException {
    constructor(
        status: HttpStatus,
        code: ErrorCode,
        message: string,
        params?: Record<string, any>
    ) {
        super({ code, message, params }, status);
    }
}


===== FILE: src/common/filters/http-exception.filter.ts =====
// backend/src/common/filters/http-exception.filter.ts
import {
    ArgumentsHost,
    Catch,
    ExceptionFilter,
    HttpException,
    HttpStatus,
} from "@nestjs/common";

function isProductionEnv() {
    return process.env.NODE_ENV === "production";
}

function extractThrownAt(stack?: string): string | null {
    if (!stack) return null;

    const lines = stack.split("\n").map((l) => l.trim());
    const frameLines = lines.filter((l) => l.startsWith("at "));

    const preferred =
        frameLines.find((l) => l.includes("/src/")) ||
        frameLines.find((l) => l.includes("\\src\\")) ||
        frameLines.find((l) => !l.includes("node_modules")) ||
        frameLines[0];

    return preferred ?? null;
}

@Catch()
export class GlobalHttpExceptionFilter implements ExceptionFilter {
    catch(exception: any, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const res = ctx.getResponse();
        const req = ctx.getRequest();

        const isHttp = exception instanceof HttpException;

        const status = isHttp
            ? exception.getStatus()
            : HttpStatus.INTERNAL_SERVER_ERROR;

        const responseBody = isHttp ? exception.getResponse() : null;

        let message: any = exception?.message ?? "Internal error";
        let code: string | undefined;
        let params: Record<string, any> | undefined;

        if (typeof responseBody === "string") {
            message = responseBody;
        } else if (responseBody && typeof responseBody === "object") {
            const rb = responseBody as Record<string, any>;

            message = rb.message ?? message;

            code = rb.code;
            params = rb.params;
        }

        const showDebug = !isProductionEnv();
        const thrownAt = showDebug ? extractThrownAt(exception?.stack) : null;

        const error = {
            statusCode: status,
            code,
            params,
            message,

            path: req?.url,
            method: req?.method,

            name: showDebug ? exception?.name : undefined,
            thrownAt: showDebug ? thrownAt : undefined,
            stack: showDebug ? exception?.stack : undefined,
        };

        res.status(status).json({
            data: null,
            error,
            meta: { timestamp: new Date().toISOString() },
        });
    }
}


===== FILE: src/common/interceptors/response-wrap.interceptor.ts =====
//backend/src/common/interceptors/response-wrap.interceptor.ts
import {
    CallHandler,
    ExecutionContext,
    Injectable,
    NestInterceptor,
} from "@nestjs/common";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

@Injectable()
export class ResponseWrapInterceptor implements NestInterceptor {
    intercept(_context: ExecutionContext, next: CallHandler): Observable<any> {
        return next.handle().pipe(
            map((data) => ({
                data,
                meta: { timestamp: new Date().toISOString() },
            })),
        );
    }
}


===== FILE: src/common/middleware/request-logger.middleware.ts =====
//backend/src/common/middleware/request-logger.middleware.ts
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class RequestLoggerMiddleware implements NestMiddleware {
    use(req: Request, _res: Response, next: NextFunction) {
        console.log("➡️ INCOMING REQUEST", {
            method: req.method,
            url: req.originalUrl,
            headers: {
                authorization: req.headers["authorization"] ?? null,
            },
            body: req.body,
        });

        next();
    }
}


===== FILE: src/config/env.validation.ts =====
import * as Joi from "joi";

export const envValidationSchema = Joi.object({
    PORT: Joi.number().default(5000),
    MONGO_URI: Joi.string().required(),
    JWT_SECRET: Joi.string().required(),
});


===== FILE: src/main.ts =====
//backend/src/main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { ValidationPipe } from "@nestjs/common";
import { ResponseWrapInterceptor } from "./common/interceptors/response-wrap.interceptor";
import { GlobalHttpExceptionFilter } from "./common/filters/http-exception.filter";

console.log("BOOT_ID", Date.now(), "PID", process.pid);

async function bootstrap() {
    const app = await NestFactory.create(AppModule);

    app.enableCors({ origin: true, credentials: true });

    app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));
    app.useGlobalInterceptors(new ResponseWrapInterceptor());
    app.useGlobalFilters(new GlobalHttpExceptionFilter());

    await app.listen(process.env.PORT ? Number(process.env.PORT) : 5000);
    console.log("Nest server running");
}

bootstrap();


===== FILE: src/seed/seed.module.ts =====
//backend/src/seed/seed.module.ts
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { UsersModule } from "../users/users.module";
import { SeedService } from "./seed.service";
import { envValidationSchema } from "../config/env.validation";
import { ClansModule } from "../clans/clans.module";
import { Clan, ClanSchema } from "../clans/clan.schema";
import { User, UserSchema } from "../users/user.schema";

@Module({
    imports: [
        ConfigModule.forRoot({
            isGlobal: true,
            validationSchema: envValidationSchema,
        }),

        MongooseModule.forRootAsync({
            inject: [ConfigService],
            useFactory: async (config: ConfigService) => ({
                uri: config.get<string>("MONGO_URI")!,
            }),
        }),
        MongooseModule.forFeature([
            { name: User.name, schema: UserSchema },
            { name: Clan.name, schema: ClanSchema },
        ]),
        UsersModule,
        ClansModule,
    ],
    providers: [SeedService],
})
export class SeedModule {}


===== FILE: src/seed/seed.service.ts =====
// backend/src/seed/seed.service.ts
import { Injectable } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { UsersService } from "../users/users.service";
import { Clan, ClanDocument } from "../clans/clan.schema";
import { User, UserDocument } from "../users/user.schema";
import { seedClans, assignUsersToClans } from "../clans/clans.seed";

@Injectable()
export class SeedService {
    constructor(
        private readonly users: UsersService,
        @InjectModel(Clan.name) private readonly clanModel: Model<ClanDocument>,
        @InjectModel(User.name) private readonly userModel: Model<UserDocument>
    ) {}

    async run() {
        // 1) Clans
        const clans = await seedClans({ clanModel: this.clanModel });

        // 2) Users
        const usersRes = await this.users.seedTestUsers(150, "123");

        // 3) Assign
        const assignRes = await assignUsersToClans({
            clanModel: this.clanModel,
            userModel: this.userModel,
            clanIds: {
                clan1Id: clans.clan1._id,
                clan2Id: clans.clan2._id,
                clan3Id: clans.clan3._id,
            },
        });

        return {
            clans: {
                clan1: { id: String(clans.clan1._id), slug: clans.clan1.slug },
                clan2: { id: String(clans.clan2._id), slug: clans.clan2.slug },
                clan3: { id: String(clans.clan3._id), slug: clans.clan3.slug },
            },
            users: usersRes,
            assign: assignRes,
        };
    }
}


===== FILE: src/seed/seed.ts =====
// backend/src/seed/seed.ts
import "reflect-metadata";
import { NestFactory } from "@nestjs/core";
import * as dotenv from "dotenv";
import { SeedModule } from "./seed.module";
import { SeedService } from "./seed.service";

async function bootstrap() {
    dotenv.config();

    if (process.env.NODE_ENV === "production") {
        throw new Error("SEED is disabled in production.");
    }
    if (!process.env.MONGO_URI) {
        throw new Error("Missing MONGO_URI");
    }

    const app = await NestFactory.createApplicationContext(SeedModule, {
        logger: ["log", "error", "warn"],
    });

    try {
        const seedService = app.get(SeedService);
        const result = await seedService.run();
        console.log("✅ Seed done:", result);
    } finally {
        await app.close();
        console.log("✅ Seed context closed");
    }
}

bootstrap().catch((err) => {
    console.error("❌ Seed failed:", err);
    process.exit(1);
});


===== FILE: src/users/dto/create-user.dto.ts =====
import { IsString, Matches, MaxLength, MinLength } from "class-validator";

export class CreateUserDto{
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    @Matches(/^[a-z0-9._-]+$/i, {
        message: "username can contain letters, numbers, dot, underscore, dash",
    })
    username!:string;

    @IsString()
    @MinLength(3)
    @MaxLength(64)
    password!:string

}



===== FILE: src/users/dto/update-me.dto.ts =====
// backend/src/users/dto/update-me.dto.ts
import { IsOptional, IsString, Matches, MaxLength, MinLength } from "class-validator";

export class UpdateMeDto {
    @IsString()
    @MinLength(1)
    currentPassword!: string;

    @IsOptional()
    @IsString()
    @MinLength(3)
    @MaxLength(32)
    @Matches(/^[a-z0-9._-]+$/i, {
        message: "username can contain letters, numbers, dot, underscore, dash",
    })
    newUsername?: string;

    @IsOptional()
    @IsString()
    @MinLength(3)
    @MaxLength(64)
    newPassword?: string;
}


===== FILE: src/users/user.schema.ts =====

import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose";
import { HydratedDocument, Types  } from "mongoose";

export type UserDocument = HydratedDocument<User>;

@Schema({ timestamps: true, versionKey: false })
export class User {
    @Prop({
        required: true,
        trim: true,
        lowercase: true,
        unique: true,
        index: true,
        minlength: 3,
        maxlength: 32,
    })
    username!: string;

    @Prop({ required: true })
    password!: string;

    @Prop({ required: true, min: 0, default: 0, index: true })
    rank!: number;

    @Prop({ type: Types.ObjectId, ref: "Clan", default: null, index: true })
    clanId!: Types.ObjectId | null;

}


export const UserSchema = SchemaFactory.createForClass(User);


===== FILE: src/users/users.controller.ts =====
// backend/src/users/users.controller.ts
import { Body, Controller, Patch, Req, UseGuards, BadRequestException } from "@nestjs/common";
import { UsersService } from "./users.service";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { UpdateMeDto } from "./dto/update-me.dto";

@Controller("users")
export class UsersController {
    constructor(private readonly users: UsersService) {}

    @UseGuards(JwtAuthGuard)
    @Patch("me")
    async updateMe(@Req() req: any, @Body() dto: UpdateMeDto) {
        if (!dto.newUsername && !dto.newPassword) {
            throw new BadRequestException("Nothing to update");
        }

        const userId = req.user.userId;
        return this.users.updateMe(userId, dto);
    }
}


===== FILE: src/users/users.module.ts =====
//backend/src/users/users.module.ts
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";
import { User, UserSchema } from "./user.schema";
import { UsersService } from "./users.service";
import { UsersController } from "./users.controller";

@Module({
    imports: [MongooseModule.forFeature([{ name: User.name, schema: UserSchema }])],
    controllers: [UsersController],
    providers: [UsersService],
    exports: [UsersService],
})
export class UsersModule {}


===== FILE: src/users/users.service.ts =====
// backend/src/users/users.service.ts
import { BadRequestException, ConflictException, Injectable, UnauthorizedException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { User, UserDocument } from "./user.schema";
import * as bcrypt from "bcryptjs";
import { UpdateMeDto } from "./dto/update-me.dto";

@Injectable()
export class UsersService {
    constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}

    findByUsername(username: string) {
        return this.userModel.findOne({ username: username.toLowerCase() }).exec();
    }

    findById(id: string) {
        return this.userModel.findById(id).exec();
    }

    async seedTestUsers(count = 50, plainPassword = "123") {
        const passwordHash = await bcrypt.hash(plainPassword, 10);

        const ops = [];
        for (let i = 1; i <= count; i++) {
            let rankRandom = Math.floor(Math.random() * 1000);
            ops.push({
                updateOne: {
                    filter: { username: `user${i}` },
                    update: {
                        $setOnInsert: { username: `user${i}`, password: passwordHash, rank: rankRandom }
                    },
                    upsert: true,
                },
            });
        }

        const res = await this.userModel.bulkWrite(ops, { ordered: false });

        return {
            inserted: res.upsertedCount || 0,
            matched: res.matchedCount || 0,
            modified: res.modifiedCount || 0,
        };
    }

    async createUser(username: string, plainPassword: string) {
        const exists = await this.findByUsername(username);
        if (exists) throw new ConflictException("Username already taken");

        const passwordHash = await bcrypt.hash(plainPassword, 10);

        const created = await this.userModel.create({
            username,
            password: passwordHash,
        });

        return { id: String(created._id), username: created.username };
    }

    async updateMe(userId: string, dto: UpdateMeDto) {
        const user = await this.userModel.findById(userId).exec();
        if (!user) throw new BadRequestException("User not found");

        const ok = await bcrypt.compare(dto.currentPassword, user.password);
        if (!ok) throw new UnauthorizedException("Invalid current password");

        if (dto.newUsername) {
            const newU = dto.newUsername.trim().toLowerCase();

            if (newU !== user.username) {
                const exists = await this.userModel.exists({ username: newU, _id: { $ne: user._id } });
                if (exists) throw new ConflictException("Username already taken");
                user.username = newU;
            }
        }

        if (dto.newPassword) {
            user.password = await bcrypt.hash(dto.newPassword, 10);
        }

        await user.save();

        return { id: String(user._id), username: user.username };
    }
}

